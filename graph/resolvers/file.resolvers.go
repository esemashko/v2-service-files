package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"main/ent"
	entfile "main/ent/file"
	"main/graph/dataloader"
	"main/graph/model"
	fileservice "main/services/file"
	"main/utils"

	"entgo.io/contrib/entgql"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, input model.UploadFileInput) (*model.FileUploadResponse, error) {
	client := r.getClient(ctx)

	// üîí [PERMISSION CHECK] –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ –∑–∞–≥—Ä—É–∑–∫—É —Ñ–∞–π–ª–æ–≤
	fileService := fileservice.NewFileService()
	if err := fileService.CanUploadFile(ctx); err != nil {
		return &model.FileUploadResponse{
			Success: false,
			Message: err.Error(),
			File:    nil,
		}, nil
	}

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º, —á—Ç–æ —Ñ–∞–π–ª –±—ã–ª –ø–µ—Ä–µ–¥–∞–Ω
	if input.File.Filename == "" {
		return &model.FileUploadResponse{
			Success: false,
			Message: utils.T(ctx, "error.file.no_file"),
			File:    nil,
		}, nil
	}

	// –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–≥—Ä—É–∂–∞–µ–º–æ–º —Ñ–∞–π–ª–µ
	utils.Logger.Info("File upload attempt",
		zap.String("filename", input.File.Filename),
		zap.Int64("size", input.File.Size),
		zap.String("content_type", input.File.ContentType))

	// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞
	const maxFileSize = 100 * 1024 * 1024 // 100MB
	if input.File.Size > maxFileSize {
		utils.Logger.Warn("File too large",
			zap.String("filename", input.File.Filename),
			zap.Int64("size", input.File.Size),
			zap.Int64("max_size", maxFileSize))
		return &model.FileUploadResponse{
			Success: false,
			Message: utils.T(ctx, "error.file.too_large"),
			File:    nil,
		}, nil
	}

	// –°–æ–∑–¥–∞–µ–º input –¥–ª—è —Ñ–∞–π–ª–æ–≤–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
	fileInput := fileservice.UploadFileInput{
		Upload:      &input.File,
		Description: input.Description,
	}

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Ä–≤–∏—Å –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞
	fileResult, err := fileService.UploadFile(ctx, client, fileInput)
	if err != nil {
		utils.Logger.Error("Failed to upload file",
			zap.Error(err),
			zap.String("filename", input.File.Filename))
		return &model.FileUploadResponse{
			Success: false,
			Message: err.Error(),
			File:    nil,
		}, nil
	}

	return &model.FileUploadResponse{
		Success: true,
		Message: utils.T(ctx, "success.file.uploaded"),
		File:    fileResult,
	}, nil
}

// UpdateFileInfo is the resolver for the updateFileInfo field.
func (r *mutationResolver) UpdateFileInfo(ctx context.Context, id uuid.UUID, input model.UpdateFileInfoInput) (*model.FileResponse, error) {
	client := r.getClient(ctx)

	// üîí [PERMISSION CHECK] –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
	fileService := fileservice.NewFileService()
	if err := fileService.CanUpdateFile(ctx, client, id); err != nil {
		return &model.FileResponse{
			Success: false,
			Message: err.Error(),
			File:    nil,
		}, nil
	}

	// –°–æ–∑–¥–∞–µ–º updater
	updater := client.File.UpdateOneID(id)

	// –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –ø–æ–ª—è
	if input.Description != nil {
		updater = updater.SetDescription(*input.Description)
	}
	if input.OriginalName != nil {
		updater = updater.SetOriginalName(*input.OriginalName)
	}

	// –í—ã–ø–æ–ª–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
	ctxWithClient := ent.NewContext(ctx, client)
	updatedFile, err := updater.Save(ctxWithClient)
	if err != nil {
		if ent.IsNotFound(err) {
			return &model.FileResponse{
				Success: false,
				Message: utils.T(ctx, "error.file.not_found"),
				File:    nil,
			}, nil
		}
		utils.Logger.Error("Failed to update file", zap.Error(err), zap.String("file_id", id.String()))
		return &model.FileResponse{
			Success: false,
			Message: utils.T(ctx, "error.file.update_failed"),
			File:    nil,
		}, nil
	}

	return &model.FileResponse{
		Success: true,
		Message: utils.T(ctx, "success.file.updated"),
		File:    updatedFile,
	}, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, id uuid.UUID) (*model.FileDeleteResponse, error) {
	client := r.getClient(ctx)

	// üîí [PERMISSION CHECK]
	fileService := fileservice.NewFileService()
	if err := fileService.CanDeleteFile(ctx, client, id); err != nil {
		return &model.FileDeleteResponse{Success: false, Message: err.Error()}, nil
	}

	// üîÑ [TRANSACTION]
	tx, err := client.Tx(ctx)
	if err != nil {
		return &model.FileDeleteResponse{Success: false, Message: utils.T(ctx, "error.transaction.failed")}, nil
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	txCtx := ent.NewTxContext(ctx, tx)

	// –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–∏—Å (–≤–∫–ª—é—á–∞–µ—Ç —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ S3 –∏ –ë–î)
	if err = fileService.DeleteFile(txCtx, tx.Client(), id); err != nil {
		utils.Logger.Error("Failed to delete file", zap.Error(err), zap.String("file_id", id.String()))
		return &model.FileDeleteResponse{Success: false, Message: err.Error()}, nil
	}

	if err = tx.Commit(); err != nil {
		return &model.FileDeleteResponse{Success: false, Message: utils.T(ctx, "error.transaction.commit_failed")}, nil
	}

	return &model.FileDeleteResponse{Success: true, Message: utils.T(ctx, "success.file.deleted")}, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id uuid.UUID) (*model.FileResponse, error) {
	client := r.getClient(ctx)

	// üîí [PERMISSION CHECK] –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä —Ñ–∞–π–ª–∞
	fileService := fileservice.NewFileService()
	if err := fileService.CanViewFile(ctx, client, id); err != nil {
		return &model.FileResponse{
			Success: false,
			Message: err.Error(),
			File:    nil,
		}, nil
	}

	// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª–∏ —Ñ–∞–π–ª–∞
	file, err := client.File.Query().
		Where(entfile.ID(id)).
		Only(ctx)

	if err != nil {
		if ent.IsNotFound(err) {
			return &model.FileResponse{
				Success: false,
				Message: utils.T(ctx, "error.file.not_found"),
				File:    nil,
			}, nil
		}
		return &model.FileResponse{
			Success: false,
			Message: utils.T(ctx, "error.file.get_failed"),
			File:    nil,
		}, nil
	}

	return &model.FileResponse{
		Success: true,
		Message: utils.T(ctx, "success.file.found"),
		File:    file,
	}, nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, after *entgql.Cursor[uuid.UUID], first *int, before *entgql.Cursor[uuid.UUID], last *int, orderBy []*ent.FileOrder, where *ent.FileWhereInput) (*ent.FileConnection, error) {
	client := r.getClient(ctx)

	// –î–ª—è —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
	// –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø—Ä–∞–≤–∞ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞ —É—Ä–æ–≤–Ω–µ –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞

	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤
	query := client.File.Query()

	// –ü—Ä–∏–º–µ–Ω—è–µ–º CollectFields –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
	query, err := query.CollectFields(ctx)
	if err != nil {
		return nil, err
	}

	// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–∞–≥–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	return query.Paginate(ctx, after, first, before, last,
		ent.WithFileFilter(where.Filter),
		ent.WithFileOrder(orderBy),
	)
}

// FileList is the resolver for the fileList field.
func (r *queryResolver) FileList(ctx context.Context, after *entgql.Cursor[uuid.UUID], first *int, before *entgql.Cursor[uuid.UUID], last *int, orderBy []*ent.FileOrder, where *ent.FileWhereInput) (*ent.FileConnection, error) {
	client := r.getClient(ctx)

	// –î–ª—è —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
	// –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø—Ä–∞–≤–∞ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞ —É—Ä–æ–≤–Ω–µ –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞

	// –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤
	query := client.File.Query()

	// –ü—Ä–∏–º–µ–Ω—è–µ–º CollectFields –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
	query, err := query.CollectFields(ctx)
	if err != nil {
		return nil, err
	}

	// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–∞–≥–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	return query.Paginate(ctx, after, first, before, last,
		ent.WithFileFilter(where.Filter),
		ent.WithFileOrder(orderBy),
	)
}

// FilesByUser is the resolver for the filesByUser field.
func (r *queryResolver) FilesByUser(ctx context.Context, userID uuid.UUID, limit *int, offset *int) (*model.FileListResponse, error) {
	client := r.getClient(ctx)

	// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
	limitValue := 20
	offsetValue := 0

	if limit != nil && *limit > 0 {
		limitValue = *limit
	}
	if offset != nil && *offset >= 0 {
		offsetValue = *offset
	}

	// –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–∏—Å
	fileService := fileservice.NewFileService()
	files, err := fileService.GetFilesByUser(ctx, client, userID, limitValue, offsetValue)
	if err != nil {
		utils.Logger.Error("Failed to get files by user",
			zap.Error(err),
			zap.String("user_id", userID.String()))
		return &model.FileListResponse{
			Success:    false,
			Message:    err.Error(),
			Files:      []*ent.File{},
			TotalCount: 0,
		}, nil
	}

	// –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–π–ª–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Å—á–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∫–∞–∫ fallback
	totalCount := len(files)

	return &model.FileListResponse{
		Success:    true,
		Message:    utils.T(ctx, "success.files.found"),
		Files:      files,
		TotalCount: totalCount,
	}, nil
}

// GetFileDownloadURL is the resolver for the getFileDownloadURL field.
func (r *mutationResolver) GetFileDownloadURL(ctx context.Context, id uuid.UUID) (*model.FileDownloadURLResponse, error) {
	client := r.getClient(ctx)

	// –ü–æ–ª—É—á–∞–µ–º pre-signed URL –¥–ª—è —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–∏—Å
	fileService := fileservice.NewFileService()
	result, err := fileService.GetFileDownloadURL(ctx, client, id)
	if err != nil {
		utils.Logger.Error("Failed to get file download URL",
			zap.Error(err),
			zap.String("file_id", id.String()))
		return &model.FileDownloadURLResponse{
			Success: false,
			Message: err.Error(),
			URL:     nil,
		}, nil
	}

	return &model.FileDownloadURLResponse{
		Success:   true,
		Message:   utils.T(ctx, "success.file.download_url_generated"),
		URL:       &result.URL,
		ExpiresAt: &result.ExpiresAt,
	}, nil
}

// GetBatchDownloadURL is the resolver for the getBatchDownloadURL field.
func (r *mutationResolver) GetBatchDownloadURL(ctx context.Context, input model.BatchDownloadInput) (*model.BatchDownloadURLResponse, error) {
	client := r.getClient(ctx)

	// FileIds —É–∂–µ —è–≤–ª—è—é—Ç—Å—è []uuid.UUID, –ø–æ—ç—Ç–æ–º—É –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–µ –Ω—É–∂–Ω–æ
	fileIDs := input.FileIds

	// –ü–æ–ª—É—á–∞–µ–º –∞—Ä—Ö–∏–≤–Ω–æ–µ –∏–º—è (–º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º)
	var archiveName string
	if input.ArchiveName != nil {
		archiveName = *input.ArchiveName
	}

	// –ü–æ–ª—É—á–∞–µ–º pre-signed URL –¥–ª—è –∞—Ä—Ö–∏–≤–∞ —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–∏—Å
	fileService := fileservice.NewFileService()
	result, err := fileService.GetBatchDownloadURL(ctx, client, fileIDs, archiveName)
	if err != nil {
		utils.Logger.Error("Failed to get batch download URL",
			zap.Error(err),
			zap.Int("file_count", len(fileIDs)))
		return &model.BatchDownloadURLResponse{
			Success:    false,
			Message:    err.Error(),
			TotalFiles: 0,
		}, nil
	}

	return &model.BatchDownloadURLResponse{
		Success:     true,
		Message:     utils.T(ctx, "success.file.batch_download_url_generated"),
		URL:         &result.URL,
		ExpiresAt:   &result.ExpiresAt,
		ArchiveName: &result.ArchiveName,
		TotalFiles:  result.TotalFiles,
	}, nil
}

// CanDelete is the resolver for the canDelete field on File.
func (r *fileResolver) CanDelete(ctx context.Context, obj *ent.File) (bool, error) {
	return dataloader.GetFileCanDelete(ctx, obj.ID)
}
